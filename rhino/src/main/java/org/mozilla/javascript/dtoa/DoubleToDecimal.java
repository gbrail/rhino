/*
 * Copyright 2018-2020 Raffaello Giulietti
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package org.mozilla.javascript.dtoa;

import static java.lang.Double.doubleToRawLongBits;
import static java.lang.Long.numberOfLeadingZeros;
import static org.mozilla.javascript.dtoa.MathUtils.flog10pow2;
import static org.mozilla.javascript.dtoa.MathUtils.flog10threeQuartersPow2;
import static org.mozilla.javascript.dtoa.MathUtils.flog2pow10;
import static org.mozilla.javascript.dtoa.MathUtils.g0;
import static org.mozilla.javascript.dtoa.MathUtils.g1;
import static org.mozilla.javascript.dtoa.MathUtils.multiplyHigh;
import static org.mozilla.javascript.dtoa.MathUtils.pow10;

/**
 * This class exposes a method to render a {@code double} as a string.
 *
 * @author Raffaello Giulietti
 */
public class DoubleToDecimal {
    /*
    For full details about this code see the following references:

    [1] Giulietti, "The Schubfach way to render doubles",
        https://drive.google.com/open?id=1luHhyQF9zKlM8yJ1nebU0OgVYhfC6CBN

    [2] IEEE Computer Society, "IEEE Standard for Floating-Point Arithmetic"

    [3] Bouvier & Zimmermann, "Division-Free Binary-to-Decimal Conversion"

    Divisions are avoided altogether for the benefit of those architectures
    that do not provide specific machine instructions or where they are slow.
    This is discussed in section 10 of [1].
     */

    // Sources with the license are here:
    // https://github.com/c4f7fcce9cb06515/Schubfach/blob/3c92d3c9b1fead540616c918cdfef432bca53dfa/todec/src/math/FloatToDecimal.java

    // The precision in bits.
    static final int P = 53;

    // Exponent width in bits.
    private static final int W = (Double.SIZE - 1) - (P - 1);

    // Minimum value of the exponent: -(2^(W-1)) - P + 3.
    static final int Q_MIN = (-1 << (W - 1)) - P + 3;

    // Threshold to detect tiny values, as in section 8.1.1 of [1]
    static final long C_TINY = 3;

    // H is as in section 8 of [1].
    static final int H = 17;

    // Minimum value of the significand of a normal value: 2^(P-1).
    private static final long C_MIN = 1L << (P - 1);

    // Mask to extract the biased exponent.
    private static final int BQ_MASK = (1 << W) - 1;

    // Mask to extract the fraction bits.
    private static final long T_MASK = (1L << (P - 1)) - 1;

    // Used in rop().
    private static final long MASK_63 = (1L << 63) - 1;

    /**
     * Returns a string rendering of the {@code double} argument.
     *
     * <p>The characters of the result are all drawn from the ASCII set.
     *
     * <ul>
     *   <li>Any NaN, whether quiet or signaling, is rendered as {@code "NaN"}, regardless of the
     *       sign bit.
     *   <li>The infinities +&infin; and -&infin; are rendered as {@code "Infinity"} and {@code
     *       "-Infinity"}, respectively.
     *   <li>The positive and negative zeroes are rendered as {@code "0.0"} and {@code "-0.0"},
     *       respectively.
     *   <li>A finite negative {@code v} is rendered as the sign '{@code -}' followed by the
     *       rendering of the magnitude -{@code v}.
     *   <li>A finite positive {@code v} is rendered in two stages:
     *       <ul>
     *         <li><em>Selection of a decimal</em>: A well-defined decimal <i>d</i><sub><code>v
     *             </code></sub> is selected to represent {@code v}.
     *         <li><em>Formatting as a string</em>: The decimal <i>d</i><sub><code>v</code></sub> is
     *             formatted as a string, either in plain or in computerized scientific notation,
     *             depending on its value.
     *       </ul>
     * </ul>
     *
     * <p>A <em>decimal</em> is a number of the form <i>d</i>&times;10<sup><i>i</i></sup> for some
     * (unique) integers <i>d</i> &gt; 0 and <i>i</i> such that <i>d</i> is not a multiple of 10.
     * These integers are the <em>significand</em> and the <em>exponent</em>, respectively, of the
     * decimal. The <em>length</em> of the decimal is the (unique) integer <i>n</i> meeting
     * 10<sup><i>n</i>-1</sup> &le; <i>d</i> &lt; 10<sup><i>n</i></sup>.
     *
     * <p>The decimal <i>d</i><sub><code>v</code></sub> for a finite positive {@code v} is defined
     * as follows:
     *
     * <ul>
     *   <li>Let <i>R</i> be the set of all decimals that round to {@code v} according to the usual
     *       round-to-closest rule of IEEE 754 floating-point arithmetic.
     *   <li>Let <i>m</i> be the minimal length over all decimals in <i>R</i>.
     *   <li>When <i>m</i> &ge; 2, let <i>T</i> be the set of all decimals in <i>R</i> with length
     *       <i>m</i>. Otherwise, let <i>T</i> be the set of all decimals in <i>R</i> with length 1
     *       or 2.
     *   <li>Define <i>d</i><sub><code>v</code></sub> as the decimal in <i>T</i> that is closest to
     *       {@code v}. Or if there are two such decimals in <i>T</i>, select the one with the even
     *       significand (there is exactly one).
     * </ul>
     *
     * <p>The (uniquely) selected decimal <i>d</i><sub><code>v</code></sub> is then formatted.
     *
     * <p>Let <i>d</i>, <i>i</i> and <i>n</i> be the significand, exponent and length of
     * <i>d</i><sub><code>v</code></sub>, respectively. Further, let <i>e</i> = <i>n</i> + <i>i</i>
     * - 1 and let <i>d</i><sub>1</sub>&hellip;<i>d</i><sub><i>n</i></sub> be the usual decimal
     * expansion of the significand. Note that <i>d</i><sub>1</sub> &ne; 0 &ne;
     * <i>d</i><sub><i>n</i></sub>.
     *
     * <ul>
     *   <li>Case -3 &le; <i>e</i> &lt; 0: <i>d</i><sub><code>v</code></sub> is formatted as <code>
     *       0.0</code>&hellip;<code>0</code>
     *       <!--
     * -->
     *       <i>d</i><sub>1</sub>&hellip;<i>d</i><sub><i>n</i></sub>, where there are exactly
     *       -(<i>n</i> + <i>i</i>) zeroes between the decimal point and <i>d</i><sub>1</sub>. For
     *       example, 123 &times; 10<sup>-4</sup> is formatted as {@code 0.0123}.
     *   <li>Case 0 &le; <i>e</i> &lt; 7:
     *       <ul>
     *         <li>Subcase <i>i</i> &ge; 0: <i>d</i><sub><code>v</code></sub> is formatted as
     *             <i>d</i><sub>1</sub>&hellip;<i>d</i><sub><i>n</i></sub>
     *             <!--
     * -->
     *             <code>0</code>&hellip;<code>0.0</code>, where there are exactly <i>i</i> zeroes
     *             between <i>d</i><sub><i>n</i></sub> and the decimal point. For example, 123
     *             &times; 10<sup>2</sup> is formatted as {@code 12300.0}.
     *         <li>Subcase <i>i</i> &lt; 0: <i>d</i><sub><code>v</code></sub> is formatted as
     *             <i>d</i><sub>1</sub>&hellip;
     *             <!--
     * -->
     *             <i>d</i><sub><i>n</i>+<i>i</i></sub>.
     *             <!--
     * -->
     *             <i>d</i><sub><i>n</i>+<i>i</i>+1</sub>&hellip;
     *             <!--
     * -->
     *             <i>d</i><sub><i>n</i></sub>. There are exactly -<i>i</i> digits to the right of
     *             the decimal point. For example, 123 &times; 10<sup>-1</sup> is formatted as
     *             {@code 12.3}.
     *       </ul>
     *   <li>Case <i>e</i> &lt; -3 or <i>e</i> &ge; 7: computerized scientific notation is used to
     *       format <i>d</i><sub><code>v</code></sub>. Here <i>e</i> is formatted as by {@link
     *       Integer#toString(int)}.
     *       <ul>
     *         <li>Subcase <i>n</i> = 1: <i>d</i><sub><code>v</code></sub> is formatted as
     *             <i>d</i><sub>1</sub><code>.0E</code><i>e</i>. For example, 1 &times;
     *             10<sup>23</sup> is formatted as {@code 1.0E23}.
     *         <li>Subcase <i>n</i> &gt; 1: <i>d</i><sub><code>v</code></sub> is formatted as
     *             <i>d</i><sub>1</sub><code>.</code><i>d</i><sub>2</sub>
     *             <!--
     * -->
     *             &hellip;<i>d</i><sub><i>n</i></sub><code>E</code><i>e</i>. For example, 123
     *             &times; 10<sup>-21</sup> is formatted as {@code 1.23E-19}.
     *       </ul>
     * </ul>
     *
     * @param v the {@code double} to be rendered.
     * @return a string rendering of the argument.
     */
    public static Decimal toDecimal(double v) {
        /*
        For full details see references [2] and [1].

        For finite v != 0, determine integers c and q such that
            |v| = c 2^q    and
            Q_MIN <= q <= Q_MAX    and
                either    2^(P-1) <= c < 2^P                 (normal)
                or        0 < c < 2^(P-1)  and  q = Q_MIN    (subnormal)
         */
        assert Double.isFinite(v);
        long bits = doubleToRawLongBits(v);
        long t = bits & T_MASK;
        int bq = (int) (bits >>> (P - 1)) & BQ_MASK;
        if (bq < BQ_MASK) {
            boolean negative = bits < 0;
            if (bq != 0) {
                // normal value. Here mq = -q
                int mq = -Q_MIN + 1 - bq;
                long c = C_MIN | t;
                // The fast path discussed in section 8.2 of [1].
                if (0 < mq && mq < P) {
                    long f = c >> mq;
                    if (f << mq == c) {
                        return new Decimal(f, 0, negative);
                    }
                }
                return toDecimal(-mq, c, 0, negative);
            }
            if (t != 0) {
                // subnormal value
                return t < C_TINY
                        ? toDecimal(Q_MIN, 10 * t, -1, negative)
                        : toDecimal(Q_MIN, t, 0, negative);
            }
            // We have landed on zero
            return new Decimal(0, 0, negative);
        }
        // We are infinite or NaN
        throw new IllegalArgumentException(String.valueOf(v));
    }

    private static Decimal toDecimal(int q, long c, int dk, boolean negative) {
        /*
        The skeleton corresponds to figure 4 of [1].
        The efficient computations are those summarized in figure 7.

        Here's a correspondence between Java names and names in [1],
        expressed as approximate LaTeX source code and informally.
        Other names are identical.
        cb:     \bar{c}     "c-bar"
        cbr:    \bar{c}_r   "c-bar-r"
        cbl:    \bar{c}_l   "c-bar-l"

        vb:     \bar{v}     "v-bar"
        vbr:    \bar{v}_r   "v-bar-r"
        vbl:    \bar{v}_l   "v-bar-l"

        rop:    r_o'        "r-o-prime"
         */
        int out = (int) c & 0x1;
        long cb = c << 2;
        long cbr = cb + 2;
        long cbl;
        int k;
        /*
        flog10pow2(e) = floor(log_10(2^e))
        flog10threeQuartersPow2(e) = floor(log_10(3/4 2^e))
        flog2pow10(e) = floor(log_2(10^e))
         */
        if (c != C_MIN || q == Q_MIN) {
            // regular spacing
            cbl = cb - 2;
            k = flog10pow2(q);
        } else {
            // irregular spacing
            cbl = cb - 1;
            k = flog10threeQuartersPow2(q);
        }
        int h = q + flog2pow10(-k) + 2;

        // g1 and g0 are as in section 9.9.3 of [1], so g = g1 2^63 + g0
        long g1 = g1(k);
        long g0 = g0(k);

        long vb = rop(g1, g0, cb << h);
        long vbl = rop(g1, g0, cbl << h);
        long vbr = rop(g1, g0, cbr << h);

        long s = vb >> 2;
        if (s >= 100) {
            /*
            For n = 17, m = 1 the table in section 10 of [1] shows
                s' = floor(s / 10) = floor(s 115_292_150_460_684_698 / 2^60)
                   = floor(s 115_292_150_460_684_698 2^4 / 2^64)

            sp10 = 10 s'
            tp10 = 10 t'
            upin    iff    u' = sp10 10^k in Rv
            wpin    iff    w' = tp10 10^k in Rv
            See section 9.4 of [1].
             */
            long sp10 = 10 * multiplyHigh(s, 115_292_150_460_684_698L << 4);
            long tp10 = sp10 + 10;
            boolean upin = vbl + out <= sp10 << 2;
            boolean wpin = (tp10 << 2) + out <= vbr;
            if (upin != wpin) {
                return makeDecimal(upin ? sp10 : tp10, k, negative);
            }
        }

        /*
        10 <= s < 100    or    s >= 100  and  u', w' not in Rv
        uin    iff    u = s 10^k in Rv
        win    iff    w = t 10^k in Rv
        See section 9.4 of [1].
         */
        long t = s + 1;
        boolean uin = vbl + out <= s << 2;
        boolean win = (t << 2) + out <= vbr;
        if (uin != win) {
            // Exactly one of u or w lies in Rv.
            return makeDecimal(uin ? s : t, k + dk, negative);
        }
        /*
        Both u and w lie in Rv: determine the one closest to v.
        See section 9.4 of [1].
         */
        long cmp = vb - ((s + t) << 1);
        return makeDecimal(cmp < 0 || (cmp == 0 && (s & 0x1) == 0) ? s : t, k + dk, negative);
    }

    private static Decimal makeDecimal(long f, int e, boolean n) {
        /*
        For details not discussed here see section 10 of [1].

        Determine len such that
            10^(len-1) <= f < 10^len
         */
        int len = flog10pow2(Long.SIZE - numberOfLeadingZeros(f));
        if (f >= pow10(len)) {
            len += 1;
        }

        /*
        Let fp and ep be the original f and e, respectively.
        Transform f and e to ensure
            10^(H-1) <= f < 10^H
            fp 10^ep = f 10^(e-H) = 0.f 10^e
         */
        f *= pow10(H - len);
        e += len;

        return new Decimal(f, e, n);
    }

    /*
    Computes rop(cp g 2^(-127)), where g = g1 2^63 + g0
    See section 9.10 and figure 5 of [1].
     */
    private static long rop(long g1, long g0, long cp) {
        long x1 = multiplyHigh(g0, cp);
        long y0 = g1 * cp;
        long y1 = multiplyHigh(g1, cp);
        long z = (y0 >>> 1) + x1;
        long vbp = y1 + (z >>> 63);
        return vbp | ((z & MASK_63) + MASK_63) >>> 63;
    }
}
