package org.mozilla.javascript;

import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.NoSuchElementException;

/**
 * This class supports a map of properties indexex by the PropertyMap class, which allows classes
 * with the same "shape" to put properties with the same name in the same slot, resulting in
 * potential optimizations for property access. When the property map reaches a certain size, it
 * switches to a regular hash map for access and collision resistance.
 */
public class IndexedSlotMap implements SlotMap {
    /** The number of slots to index using the property map. */
    static final int FAST_SLOT_SIZE = 100;

    private final Slot[] fastSlots = new Slot[FAST_SLOT_SIZE];
    private int fastSize = 0;
    private LinkedHashMap<Object, Slot> slowSlots = null;
    private PropertyMap propertyMap = PropertyMap.ROOT;

    @Override
    public int size() {
        return fastSize + (slowSlots == null ? 0 : slowSlots.size());
    }

    @Override
    public boolean isEmpty() {
        return fastSize == 0 && (slowSlots == null || slowSlots.isEmpty());
    }

    @Override
    public Slot query(Object k, int index) {
        Object key = makeKey(k, index);
        if (fastSize > 0) {
            // Find the property in the fast map
            int ix = propertyMap.find(key);
            if (ix >= 0) {
                assert (ix < fastSize);
                return fastSlots[ix];
            }
        }
        if (slowSlots == null) {
            return null;
        }
        // If we get here, then the fast map is not being used or is not found,
        // so return nothing.
        return slowSlots.get(key);
    }

    /**
     * This implementation of getFastKey will always return a key for properties up to the size of
     * the fast property map.
     */
    @Override
    public FastKey getFastKey(Object k, int index) {
        Object key = makeKey(k, index);
        if (fastSize > 0) {
            // Find the property in the fast map and construct a key
            int ix = propertyMap.find(key);
            if (ix >= 0) {
                assert (ix < fastSize);
                return new FastKey(propertyMap, ix);
            }
        }
        return null;
    }

    /**
     * This implementation will return true for keys that were generated by getFastKey on objects
     * with the same property map.
     */
    @Override
    public boolean isFastKeyValid(FastKey key) {
        return (key.map == propertyMap && key.index < fastSize);
    }

    /**
     * This implementation will return the slot if and only if isFastKeyValid was previously called
     * and the object has not been modified since.
     */
    @Override
    public Slot queryFastNoCheck(FastKey key) {
        assert key.map == propertyMap;
        assert key.index < fastSize;
        return fastSlots[key.index];
    }

    /**
     * When inserting a new key, this implementation will move to a new property map that includes
     * the new key, and when the size of the fast keys has been exhausted, will switch to a HashMap
     * based implementation.
     *
     * <p>This works better for large objects, since it is not always the case that we mostly access
     * older properties of larger objects more often, and checking both maps results in twice the
     * cost.
     */
    @Override
    public Slot modify(Object k, int index, int attributes) {
        Object key = makeKey(k, index);
        if (slowSlots != null) {
            // There will only be slow or fast slots, so if there are
            // slow slots, then that is the only place to look.
            assert fastSize == 0;
            return slowSlots.computeIfAbsent(
                    key,
                    kk -> {
                        int indexOrHash = (kk != null ? kk.hashCode() : index);
                        return new Slot(kk, indexOrHash, attributes);
                    });
        }

        if (fastSize > 0) {
            int ix = propertyMap.find(key);
            if (ix >= 0) {
                assert (ix < fastSize);
                return fastSlots[ix];
            }
        }
        // If we get here, then we have enough room in the fast slots, but
        // most expand.
        int indexOrHash = (k != null ? k.hashCode() : index);
        Slot newSlot = new Slot(k, indexOrHash, attributes);
        insertNewSlot(key, newSlot);
        return newSlot;
    }

    @Override
    public void replace(Slot oldSlot, Slot newSlot) {
        Object key = makeKey(oldSlot.name, oldSlot.indexOrHash);
        if (fastSize > 0) {
            int ix = propertyMap.find(key);
            if (ix >= 0) {
                assert (ix < fastSize);
                fastSlots[ix] = newSlot;
                return;
            }
        }
        if (slowSlots != null) {
            slowSlots.put(key, newSlot);
        }
    }

    @Override
    public void add(Slot newSlot) {
        insertNewSlot(makeKey(newSlot.name, newSlot.indexOrHash), newSlot);
    }

    /**
     * This implementation of remove always switches us to a HashMap implementation, because it is
     * too complicated otherwise. This works because property removal is fairly uncommon.
     */
    @Override
    public void remove(Object k, int index) {
        // Fast slots are incompatible with removing stuff.
        // Switch entirely to slow slots in this case.
        // TODO: We can optimize this if removing the last property in the map
        makeSlow();

        // Now do the actual removal
        Object key = makeKey(k, index);
        Slot slot = slowSlots.get(key);
        if (slot != null) {
            // non-configurable
            if ((slot.getAttributes() & ScriptableObject.PERMANENT) != 0) {
                Context cx = Context.getContext();
                if (cx.isStrictMode()) {
                    throw ScriptRuntime.typeErrorById(
                            "msg.delete.property.with.configurable.false", key);
                }
                return;
            }
            slowSlots.remove(key);
        }
    }

    @Override
    public Iterator<Slot> iterator() {
        return new Iter();
    }

    private void insertNewSlot(Object key, Slot newSlot) {
        if (propertyMap != null && fastSize < FAST_SLOT_SIZE) {
            // We have room in the map, so switch to a new
            // property map that includes the new key.
            propertyMap = propertyMap.add(key);
            fastSlots[fastSize] = newSlot;
            fastSize++;
            assert (fastSize == propertyMap.getLevel() + 1);

        } else {
            // Once the fast slots are full, switch entirely to the hash table.
            if (slowSlots == null) {
                makeSlow();
            }
            slowSlots.put(key, newSlot);
        }
    }

    private void makeSlow() {
        // Need to re-build the whole map so that insertion order is preserved.
        LinkedHashMap<Object, Slot> newSlots = new LinkedHashMap<>();
        for (int i = 0; i < fastSize; i++) {
            Slot s = fastSlots[i];
            Object key = makeKey(s.name, s.indexOrHash);
            newSlots.put(key, s);
        }
        fastSize = 0;
        propertyMap = null;
        if (slowSlots != null) {
            newSlots.putAll(slowSlots);
        }
        slowSlots = newSlots;
    }

    private Object makeKey(Object key, int index) {
        if (key == null) {
            return index;
        }
        return key;
    }

    private final class Iter implements Iterator<Slot> {
        private Iterator<Slot> iter = null;
        private int fastIx = 0;
        private boolean done;

        Iter() {
            done = (fastSize == 0) && (slowSlots == null || slowSlots.isEmpty());
        }

        @Override
        public boolean hasNext() {
            return !done;
        }

        @Override
        public Slot next() {
            if (fastIx < fastSize) {
                Slot s = fastSlots[fastIx];
                fastIx++;
                if (fastIx == fastSize && slowSlots == null) {
                    done = true;
                }
                return s;
            }
            if (iter == null) {
                if (slowSlots == null) {
                    throw new NoSuchElementException();
                }
                iter = slowSlots.values().iterator();
            }
            Slot s = iter.next();
            if (!iter.hasNext()) {
                done = true;
            }
            return s;
        }
    }
}
